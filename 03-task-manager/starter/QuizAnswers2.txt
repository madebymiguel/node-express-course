1. In this lesson, you created a middleware function called asyncWrapper. Why?

The reason we created the middleware function called asyncWrapper is because we didn't want to repeat the same try/catch format for all of the routes. This higher order function allows us to have that reusable functionally and allows us to pass any error to error middleware by using the next function.

2. Suppose that you want to make sure that both a status code and and error message are send back to the user when they request the URL for a task that does not exist. Assume that youâ€™ve created a CustomAPIError class and an error handler that references that class. Complete the code:

const getTask = asyncWrapper(async (req, res, next) => {
  const { id: taskID } = req.params;
  const task = await Task.findOne({ _id: taskID });

  if (!task) {
    // your code here
    return next(createCustomError(`No Task With ID: ${taskID}`, 404));
  }

  res.status(200).json({ task });
});